import * as externals from "./externals";
import {URef, AccessRights} from "./uref";
import {Error, ErrorCode} from "./error";
import {CLValue} from "./clvalue";
import {Key, PublicKey} from "./key";
import {toBytesString,
        toBytesVecT,
        fromBytesMap,
        fromBytesString} from "./bytesrepr";
import {U512} from "./bignum";
import {UREF_SERIALIZED_LENGTH, KEY_UREF_SERIALIZED_LENGTH} from "./constants";
import {Pair} from "./pair";

// NOTE: interfaces aren't supported in AS yet: https://github.com/AssemblyScript/assemblyscript/issues/146#issuecomment-399130960
// interface ToBytes {
//   fromBytes(bytes: Uint8Array): ToBytes;
// }

/**
 * Length of address
 */
const ADDR_LENGTH = 32;

/**
 * System contract types.
 */
export const enum SystemContract {
  /**
   * Mint contract.
   */
  Mint = 0,
  /**
   * Proof of Stake contract.
   */
  ProofOfStake = 1,
  /**
   * Standard Payment contract.
   */
  StandardPayment = 2,
}

/**
 * Returns size in bytes of I-th parameter
 *
 * @internal
 * @param i I-th parameter
 */
export function getArgSize(i: u32): U32 | null {
  // TODO: Docs aren't clear on pointers, but perhaps `var size = <u32>0; changetype<usize>(size);` might take a pointer of a value we could pass
  let size = new Array<u32>(1);
  size[0] = 0;

  let ret = externals.get_arg_size(i, size.dataStart);
  if (ret > 0) {
    return null;
  }
  return changetype<U32>(size[0]);
}

/**
 * Returns the i-th argument passed to the host for the current module
 * invocation.
 *
 * Note that this is only relevant to contracts stored on-chain since a
 * contract deployed directly is not invoked with any arguments.
 *
 * @param i I-th parameter
 * @returns Array of bytes with ABI serialized argument. A null value if
 * given parameter is not present.
 */
export function getArg(i: u32): Uint8Array | null {
  let arg_size = getArgSize(i);
  if (arg_size === null) {
    return null;
  }
  let arg_size_u32 = changetype<u32>(arg_size);
  let data = new Uint8Array(arg_size_u32);
  let ret = externals.get_arg(i, data.dataStart, arg_size_u32);
  if (ret > 0) {
    // TODO: Error handling with standarized errors enum
    return null;
  }
  return data;
}

/**
 * Reads a given amount of bytes from a host buffer
 *
 * @internal
 * @param count Number of bytes
 * @returns A byte array with bytes received, otherwise a null in case of
 * errors.
 */
export function readHostBuffer(count: u32): Uint8Array | null {
  let result = new Uint8Array(count);
  let resultSize = new Uint32Array(1);

  let ret = externals.read_host_buffer(result.dataStart, result.length, resultSize.dataStart);
  if (ret > 0) {
    return null;
  }
  return result;
}

/**
 * Returns an [[URef]] for a given system contract
 *
 * @param system_contract System contract variant
 * @returns A valid [[URef]] that points at system contract, otherwise null.
 */
export function getSystemContract(system_contract: SystemContract): URef | null {
  let data = new Uint8Array(UREF_SERIALIZED_LENGTH);
  let ret = externals.get_system_contract(<u32>system_contract, data.dataStart, data.length);
  if (ret > 0) {
    // TODO: revert
    return null;
  }
  let decodeResult = URef.fromBytes(data);
  if (decodeResult.hasError()) {
    return null;
  }
  return decodeResult.value;
}

/**
 * Stores the serialized bytes of an exported function as a new contract under
 * a [[URef]] generated by the host.
 *
 * @param name Name of the exported function
 * @param namedKeysBytes Serialized bytes of named keys. Use
 * {@link toBytesMap} to serialize pairs.
 */
export function storeFunction(name: String, namedKeysBytes: u8[]): Key {
  var nameBytes = toBytesString(name);
  var addr = new Uint8Array(ADDR_LENGTH);
  externals.store_function(
      <usize>nameBytes.dataStart,
      nameBytes.length,
      <usize>namedKeysBytes.dataStart,
      namedKeysBytes.length,
      <usize>addr.dataStart
  );
  let uref = new URef(addr, AccessRights.READ_ADD_WRITE);
  return Key.fromURef(uref);
}

/**
 * Stores the serialized bytes of an exported function as a new contract at an
 * immutable address generated by the host.
 *
 * @param name Name of the exported function
 * @param namedKeysBytes Serialized bytes of named keys. Use
 * {@link toBytesMap} to serialize pairs.
 */
export function storeFunctionAtHash(name: String, namedKeysBytes: u8[]): Key | null {
  var nameBytes = toBytesString(name);
  var addr = new Uint8Array(ADDR_LENGTH);
  externals.store_function_at_hash(
      <usize>nameBytes.dataStart,
      nameBytes.length,
      <usize>namedKeysBytes.dataStart,
      namedKeysBytes.length,
      <usize>addr.dataStart
  );
  return Key.fromHash(addr);
}

/**
 * Calls the given stored contract, passing the given arguments to it.
 *
 * If the stored contract calls [[ret]], then that value is returned from [[callContract]].  If the
 * stored contract calls [[Error.revert]], then execution stops and [[callContract]] doesn't return.
 * Otherwise [[callContract]] returns null.
 *
 * @param key A key under which a contract is stored
 * @param args A list of values
 * @returns Bytes of the contract's return value.
 */
export function callContract(key: Key, args: CLValue[]): Uint8Array | null {
  let keyBytes = key.toBytes();
  let argBytes = toBytesVecT(args);

  let resultSize = new Uint32Array(1);
  resultSize.fill(0);

  let ret = externals.call_contract(
      <usize>keyBytes.dataStart,
      keyBytes.length,
      argBytes.dataStart,
      argBytes.length,
      resultSize.dataStart,
  );
  if (ret > 0) {
    return null;
  }

  let hostBufSize = resultSize[0];
  if (hostBufSize > 0) {
    return readHostBuffer(hostBufSize);
  } else {
    return new Uint8Array(0);
  }
}

/**
 * Stores the given [[Key]] under a given name in the current context's named keys.
 *
 * The current context is either the caller's account or a stored contract
 * depending on whether the currently-executing module is a direct call or a
 * sub-call respectively.
 *
 * @category Runtime
 */
export function putKey(name: String, key: Key): void {
  var nameBytes = toBytesString(name);
  var keyBytes = key.toBytes();
  externals.put_key(
    nameBytes.dataStart,
    nameBytes.length,
    keyBytes.dataStart,
    keyBytes.length
  );
}

/**
 * Removes the [[Key]] stored under `name` in the current context's named keys.
 *
 * The current context is either the caller's account or a stored contract depending on whether the
 * currently-executing module is a direct call or a sub-call respectively.
 *
 * @param name Name of the key in current context's named keys
 * @returns An instance of [[Key]] if it exists, or a `null` otherwise.
 */
export function getKey(name: String): Key | null {
  var nameBytes = toBytesString(name);
  let keyBytes = new Uint8Array(KEY_UREF_SERIALIZED_LENGTH);
  let resultSize = new Uint32Array(1);
  let ret =  externals.get_key(
      nameBytes.dataStart,
      nameBytes.length,
      keyBytes.dataStart,
      keyBytes.length,
      resultSize.dataStart,
  );
  const error = Error.fromResult(ret);
  if (error !== null) {
    error.revert();
    return null;
  }
  let key = Key.fromBytes(keyBytes.slice(0, <i32>resultSize[0])); // total guess
  return key.ok();
}

/**
 * Returns the given [[CLValue]] to the host, terminating the currently
 * running module.
 *
 * Note this function is only relevant to contracts stored on chain which are
 * invoked via [[callContract]] and can thus return a value to their caller.
 * The return value of a directly deployed contract is never used.
 */
export function ret(value: CLValue): void {
  const valueBytes = value.toBytes();
  externals.ret(
    valueBytes.dataStart,
    valueBytes.length
  );
  unreachable();
}

/**
 * Returns `true` if `name` exists in the current context's named keys.
 *
 * The current context is either the caller's account or a stored contract depending on whether the
 * currently-executing module is a direct call or a sub-call respectively.
 *
 * @param name Name of the key
 */
export function hasKey(name: String): bool {
  const nameBytes = toBytesString(name);
  let ret = externals.has_key(nameBytes.dataStart, nameBytes.length);
  return ret == 0;
}

/**
 * Returns the current block time.
 */
export function getBlockTime(): u64 {
  let bytes = new Uint64Array(1);
  externals.get_blocktime(bytes.dataStart);
  return <u64>bytes[0];
}

/**
 * Returns the caller of the current context, i.e. the [[PublicKey]] of the
 * account which made the deploy request.
 */
export function getCaller(): PublicKey {
  let outputSize = new Uint32Array(1);
  let ret = externals.get_caller(outputSize.dataStart);
  const error = Error.fromResult(ret);
  if (error != null) {
    error.revert();
    return <PublicKey>unreachable();
  }
  const publicKeyBytes = readHostBuffer(outputSize[0]);
  if (publicKeyBytes === null) {
    Error.fromErrorCode(ErrorCode.Deserialize).revert();
    return <PublicKey>unreachable();
  }
  const publicKeyResult = PublicKey.fromBytes(publicKeyBytes);
  if (publicKeyResult.hasError()) {
    Error.fromErrorCode(ErrorCode.Deserialize).revert();
    return <PublicKey>unreachable();
  }
  return publicKeyResult.value;
}

/**
 * The phase in which a given contract is executing.
 */
export enum Phase {
  /**
   * Set while committing the genesis or upgrade configurations.
   */
  System = 0,
  /**
   * Set while executing the payment code of a deploy.
   */
  Payment = 1,
  /**
   * Set while executing the session code of a deploy.
   */
  Session = 2,
  /**
   * Set while finalizing payment at the end of a deploy.
   */
  FinalizePayment = 3,
}

/**
 * Returns the current [[Phase]].
 */
export function getPhase(): Phase {
  let bytes = new Uint8Array(1);
  externals.get_phase(bytes.dataStart);
  const phase = bytes[0];
  return <Phase>phase;
}

/**
 * Removes the [[Key]] stored under `name` in the current context's named keys.
 *
 * The current context is either the caller's account or a stored contract depending on whether the
 * currently-executing module is a direct call or a sub-call respectively.
 */
export function removeKey(name: String): void{
  var nameBytes = toBytesString(name);
  externals.remove_key(nameBytes.dataStart, nameBytes.length);
}

/**
 * Returns the named keys of the current context.
 *
 * The current context is either the caller's account or a stored contract depending on whether the
 * currently-executing module is a direct call or a sub-call respectively.
 *
 * @returns An array of String and [[Key]] pairs
 */
export function listNamedKeys(): Array<Pair<String, Key>> {
  let totalKeys = new Uint32Array(1);
  let resultSize = new Uint32Array(1);

  const res = externals.load_named_keys(totalKeys.dataStart, resultSize.dataStart);
  const error = Error.fromResult(res);
  if (error != null) {
    error.revert();
    return <Array<Pair<String, Key>>>unreachable();
  }

  if (totalKeys[0] == 0) {
    return new Array<Pair<String, Key>>();
  }

  let mapBytes = readHostBuffer(resultSize[0]);
  if (mapBytes === null) {
    Error.fromErrorCode(ErrorCode.HostBufferEmpty).revert();
    return <Array<Pair<String, Key>>>unreachable();
  }
  let maybeMap = fromBytesMap<String, Key>(
    mapBytes,
    fromBytesString,
    Key.fromBytes);

  if (maybeMap.hasError()) {
    Error.fromErrorCode(ErrorCode.Deserialize).revert();
    return <Array<Pair<String, Key>>>unreachable();
  }
  return maybeMap.value;
}

/**
 * Takes the name of an exported function to store as a contract under the given
 * [[URef]] which should already reference a stored contract.
 *
 * If successful, this overwrites the value under `uref` with a new contract instance containing
 * the original contract's named_keys, the current protocol version, and the newly created bytes of
 * the stored function.
 */
export function upgradeContractAtURef(name: String, uref: URef): void {
  const nameBytes = toBytesString(name);
  const key = Key.fromURef(uref);
  const keyBytes = key.toBytes();
  let ret = externals.upgrade_contract_at_uref(
      nameBytes.dataStart,
      nameBytes.length,
      keyBytes.dataStart,
      keyBytes.length
  );
  if (ret < 1)
    return;
  const error = Error.fromResult(ret);
  if(error !== null)
    error.revert();
}
