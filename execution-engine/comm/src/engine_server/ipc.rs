// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Deploy {
    // message fields
    pub pk: ::std::vec::Vec<u8>,
    pub timestamp: i64,
    pub session_code: ::std::vec::Vec<u8>,
    pub payment_code: ::std::vec::Vec<u8>,
    pub gas_limit: i64,
    pub gas_price: i64,
    pub nonce: i64,
    pub deploy_sig: ::std::vec::Vec<u8>,
    pub payment_sig: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Deploy {
    pub fn new() -> Deploy {
        ::std::default::Default::default()
    }

    // bytes pk = 1;

    pub fn clear_pk(&mut self) {
        self.pk.clear();
    }

    // Param is passed by value, moved
    pub fn set_pk(&mut self, v: ::std::vec::Vec<u8>) {
        self.pk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pk
    }

    // Take field
    pub fn take_pk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pk, ::std::vec::Vec::new())
    }

    pub fn get_pk(&self) -> &[u8] {
        &self.pk
    }

    // int64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }

    // bytes session_code = 3;

    pub fn clear_session_code(&mut self) {
        self.session_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.session_code
    }

    // Take field
    pub fn take_session_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.session_code, ::std::vec::Vec::new())
    }

    pub fn get_session_code(&self) -> &[u8] {
        &self.session_code
    }

    // bytes payment_code = 4;

    pub fn clear_payment_code(&mut self) {
        self.payment_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_code
    }

    // Take field
    pub fn take_payment_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_code, ::std::vec::Vec::new())
    }

    pub fn get_payment_code(&self) -> &[u8] {
        &self.payment_code
    }

    // int64 gas_limit = 5;

    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: i64) {
        self.gas_limit = v;
    }

    pub fn get_gas_limit(&self) -> i64 {
        self.gas_limit
    }

    // int64 gas_price = 6;

    pub fn clear_gas_price(&mut self) {
        self.gas_price = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_price(&mut self, v: i64) {
        self.gas_price = v;
    }

    pub fn get_gas_price(&self) -> i64 {
        self.gas_price
    }

    // int64 nonce = 7;

    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }

    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }

    // bytes deploy_sig = 8;

    pub fn clear_deploy_sig(&mut self) {
        self.deploy_sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_deploy_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.deploy_sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deploy_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deploy_sig
    }

    // Take field
    pub fn take_deploy_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deploy_sig, ::std::vec::Vec::new())
    }

    pub fn get_deploy_sig(&self) -> &[u8] {
        &self.deploy_sig
    }

    // bytes payment_sig = 9;

    pub fn clear_payment_sig(&mut self) {
        self.payment_sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_sig
    }

    // Take field
    pub fn take_payment_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_sig, ::std::vec::Vec::new())
    }

    pub fn get_payment_sig(&self) -> &[u8] {
        &self.payment_sig
    }
}

impl ::protobuf::Message for Deploy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pk)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.session_code)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_code)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gas_limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gas_price = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.deploy_sig)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.pk);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.session_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.session_code);
        }
        if !self.payment_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_code);
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.gas_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gas_price != 0 {
            my_size += ::protobuf::rt::value_size(6, self.gas_price, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.deploy_sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.deploy_sig);
        }
        if !self.payment_sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.payment_sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pk.is_empty() {
            os.write_bytes(1, &self.pk)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        if !self.session_code.is_empty() {
            os.write_bytes(3, &self.session_code)?;
        }
        if !self.payment_code.is_empty() {
            os.write_bytes(4, &self.payment_code)?;
        }
        if self.gas_limit != 0 {
            os.write_int64(5, self.gas_limit)?;
        }
        if self.gas_price != 0 {
            os.write_int64(6, self.gas_price)?;
        }
        if self.nonce != 0 {
            os.write_int64(7, self.nonce)?;
        }
        if !self.deploy_sig.is_empty() {
            os.write_bytes(8, &self.deploy_sig)?;
        }
        if !self.payment_sig.is_empty() {
            os.write_bytes(9, &self.payment_sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Deploy {
        Deploy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pk",
                    |m: &Deploy| { &m.pk },
                    |m: &mut Deploy| { &mut m.pk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &Deploy| { &m.timestamp },
                    |m: &mut Deploy| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "session_code",
                    |m: &Deploy| { &m.session_code },
                    |m: &mut Deploy| { &mut m.session_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_code",
                    |m: &Deploy| { &m.payment_code },
                    |m: &mut Deploy| { &mut m.payment_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gas_limit",
                    |m: &Deploy| { &m.gas_limit },
                    |m: &mut Deploy| { &mut m.gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gas_price",
                    |m: &Deploy| { &m.gas_price },
                    |m: &mut Deploy| { &mut m.gas_price },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nonce",
                    |m: &Deploy| { &m.nonce },
                    |m: &mut Deploy| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "deploy_sig",
                    |m: &Deploy| { &m.deploy_sig },
                    |m: &mut Deploy| { &mut m.deploy_sig },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_sig",
                    |m: &Deploy| { &m.payment_sig },
                    |m: &mut Deploy| { &mut m.payment_sig },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Deploy>(
                    "Deploy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Deploy {
        static mut instance: ::protobuf::lazy::Lazy<Deploy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Deploy,
        };
        unsafe {
            instance.get(Deploy::new)
        }
    }
}

impl ::protobuf::Clear for Deploy {
    fn clear(&mut self) {
        self.clear_pk();
        self.clear_timestamp();
        self.clear_session_code();
        self.clear_payment_code();
        self.clear_gas_limit();
        self.clear_gas_price();
        self.clear_nonce();
        self.clear_deploy_sig();
        self.clear_payment_sig();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Deploy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deploy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Op {
    // message oneof groups
    pub op_instance: ::std::option::Option<Op_oneof_op_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Op_oneof_op_instance {
    read(ReadOp),
    write(WriteOp),
    add(AddOp),
    noop(NoOp),
}

impl Op {
    pub fn new() -> Op {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.ReadOp read = 1;

    pub fn clear_read(&mut self) {
        self.op_instance = ::std::option::Option::None;
    }

    pub fn has_read(&self) -> bool {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::read(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: ReadOp) {
        self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::read(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read(&mut self) -> &mut ReadOp {
        if let ::std::option::Option::Some(Op_oneof_op_instance::read(_)) = self.op_instance {
        } else {
            self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::read(ReadOp::new()));
        }
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::read(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read(&mut self) -> ReadOp {
        if self.has_read() {
            match self.op_instance.take() {
                ::std::option::Option::Some(Op_oneof_op_instance::read(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadOp::new()
        }
    }

    pub fn get_read(&self) -> &ReadOp {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::read(ref v)) => v,
            _ => ReadOp::default_instance(),
        }
    }

    // .io.casperlabs.ipc.WriteOp write = 2;

    pub fn clear_write(&mut self) {
        self.op_instance = ::std::option::Option::None;
    }

    pub fn has_write(&self) -> bool {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::write(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: WriteOp) {
        self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::write(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write(&mut self) -> &mut WriteOp {
        if let ::std::option::Option::Some(Op_oneof_op_instance::write(_)) = self.op_instance {
        } else {
            self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::write(WriteOp::new()));
        }
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::write(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write(&mut self) -> WriteOp {
        if self.has_write() {
            match self.op_instance.take() {
                ::std::option::Option::Some(Op_oneof_op_instance::write(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteOp::new()
        }
    }

    pub fn get_write(&self) -> &WriteOp {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::write(ref v)) => v,
            _ => WriteOp::default_instance(),
        }
    }

    // .io.casperlabs.ipc.AddOp add = 3;

    pub fn clear_add(&mut self) {
        self.op_instance = ::std::option::Option::None;
    }

    pub fn has_add(&self) -> bool {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::add(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: AddOp) {
        self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::add(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut AddOp {
        if let ::std::option::Option::Some(Op_oneof_op_instance::add(_)) = self.op_instance {
        } else {
            self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::add(AddOp::new()));
        }
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::add(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add(&mut self) -> AddOp {
        if self.has_add() {
            match self.op_instance.take() {
                ::std::option::Option::Some(Op_oneof_op_instance::add(v)) => v,
                _ => panic!(),
            }
        } else {
            AddOp::new()
        }
    }

    pub fn get_add(&self) -> &AddOp {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::add(ref v)) => v,
            _ => AddOp::default_instance(),
        }
    }

    // .io.casperlabs.ipc.NoOp noop = 4;

    pub fn clear_noop(&mut self) {
        self.op_instance = ::std::option::Option::None;
    }

    pub fn has_noop(&self) -> bool {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::noop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noop(&mut self, v: NoOp) {
        self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::noop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noop(&mut self) -> &mut NoOp {
        if let ::std::option::Option::Some(Op_oneof_op_instance::noop(_)) = self.op_instance {
        } else {
            self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::noop(NoOp::new()));
        }
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::noop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noop(&mut self) -> NoOp {
        if self.has_noop() {
            match self.op_instance.take() {
                ::std::option::Option::Some(Op_oneof_op_instance::noop(v)) => v,
                _ => panic!(),
            }
        } else {
            NoOp::new()
        }
    }

    pub fn get_noop(&self) -> &NoOp {
        match self.op_instance {
            ::std::option::Option::Some(Op_oneof_op_instance::noop(ref v)) => v,
            _ => NoOp::default_instance(),
        }
    }
}

impl ::protobuf::Message for Op {
    fn is_initialized(&self) -> bool {
        if let Some(Op_oneof_op_instance::read(ref v)) = self.op_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Op_oneof_op_instance::write(ref v)) = self.op_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Op_oneof_op_instance::add(ref v)) = self.op_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Op_oneof_op_instance::noop(ref v)) = self.op_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::read(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::write(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::add(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.op_instance = ::std::option::Option::Some(Op_oneof_op_instance::noop(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.op_instance {
            match v {
                &Op_oneof_op_instance::read(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Op_oneof_op_instance::write(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Op_oneof_op_instance::add(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Op_oneof_op_instance::noop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.op_instance {
            match v {
                &Op_oneof_op_instance::read(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Op_oneof_op_instance::write(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Op_oneof_op_instance::add(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Op_oneof_op_instance::noop(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Op {
        Op::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReadOp>(
                    "read",
                    Op::has_read,
                    Op::get_read,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WriteOp>(
                    "write",
                    Op::has_write,
                    Op::get_write,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AddOp>(
                    "add",
                    Op::has_add,
                    Op::get_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NoOp>(
                    "noop",
                    Op::has_noop,
                    Op::get_noop,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Op>(
                    "Op",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Op {
        static mut instance: ::protobuf::lazy::Lazy<Op> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Op,
        };
        unsafe {
            instance.get(Op::new)
        }
    }
}

impl ::protobuf::Clear for Op {
    fn clear(&mut self) {
        self.clear_read();
        self.clear_write();
        self.clear_add();
        self.clear_noop();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Op {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOp {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReadOp {
    pub fn new() -> ReadOp {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReadOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOp {
        ReadOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ReadOp>(
                    "ReadOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadOp {
        static mut instance: ::protobuf::lazy::Lazy<ReadOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadOp,
        };
        unsafe {
            instance.get(ReadOp::new)
        }
    }
}

impl ::protobuf::Clear for ReadOp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteOp {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteOp {
    pub fn new() -> WriteOp {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WriteOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteOp {
        WriteOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WriteOp>(
                    "WriteOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteOp {
        static mut instance: ::protobuf::lazy::Lazy<WriteOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteOp,
        };
        unsafe {
            instance.get(WriteOp::new)
        }
    }
}

impl ::protobuf::Clear for WriteOp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddOp {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddOp {
    pub fn new() -> AddOp {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddOp {
        AddOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AddOp>(
                    "AddOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddOp {
        static mut instance: ::protobuf::lazy::Lazy<AddOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddOp,
        };
        unsafe {
            instance.get(AddOp::new)
        }
    }
}

impl ::protobuf::Clear for AddOp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NoOp {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NoOp {
    pub fn new() -> NoOp {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NoOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoOp {
        NoOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<NoOp>(
                    "NoOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NoOp {
        static mut instance: ::protobuf::lazy::Lazy<NoOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NoOp,
        };
        unsafe {
            instance.get(NoOp::new)
        }
    }
}

impl ::protobuf::Clear for NoOp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message oneof groups
    pub key_instance: ::std::option::Option<Key_oneof_key_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Key_oneof_key_instance {
    account(KeyAccount),
    hash(KeyHash),
    uref(KeyURef),
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.KeyAccount account = 1;

    pub fn clear_account(&mut self) {
        self.key_instance = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::account(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: KeyAccount) {
        self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::account(v))
    }

    // Mutable pointer to the field.
    pub fn mut_account(&mut self) -> &mut KeyAccount {
        if let ::std::option::Option::Some(Key_oneof_key_instance::account(_)) = self.key_instance {
        } else {
            self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::account(KeyAccount::new()));
        }
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::account(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account(&mut self) -> KeyAccount {
        if self.has_account() {
            match self.key_instance.take() {
                ::std::option::Option::Some(Key_oneof_key_instance::account(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyAccount::new()
        }
    }

    pub fn get_account(&self) -> &KeyAccount {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::account(ref v)) => v,
            _ => KeyAccount::default_instance(),
        }
    }

    // .io.casperlabs.ipc.KeyHash hash = 2;

    pub fn clear_hash(&mut self) {
        self.key_instance = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: KeyHash) {
        self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash(&mut self) -> &mut KeyHash {
        if let ::std::option::Option::Some(Key_oneof_key_instance::hash(_)) = self.key_instance {
        } else {
            self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::hash(KeyHash::new()));
        }
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash(&mut self) -> KeyHash {
        if self.has_hash() {
            match self.key_instance.take() {
                ::std::option::Option::Some(Key_oneof_key_instance::hash(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyHash::new()
        }
    }

    pub fn get_hash(&self) -> &KeyHash {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::hash(ref v)) => v,
            _ => KeyHash::default_instance(),
        }
    }

    // .io.casperlabs.ipc.KeyURef uref = 3;

    pub fn clear_uref(&mut self) {
        self.key_instance = ::std::option::Option::None;
    }

    pub fn has_uref(&self) -> bool {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::uref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uref(&mut self, v: KeyURef) {
        self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::uref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uref(&mut self) -> &mut KeyURef {
        if let ::std::option::Option::Some(Key_oneof_key_instance::uref(_)) = self.key_instance {
        } else {
            self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::uref(KeyURef::new()));
        }
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::uref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uref(&mut self) -> KeyURef {
        if self.has_uref() {
            match self.key_instance.take() {
                ::std::option::Option::Some(Key_oneof_key_instance::uref(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyURef::new()
        }
    }

    pub fn get_uref(&self) -> &KeyURef {
        match self.key_instance {
            ::std::option::Option::Some(Key_oneof_key_instance::uref(ref v)) => v,
            _ => KeyURef::default_instance(),
        }
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        if let Some(Key_oneof_key_instance::account(ref v)) = self.key_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Key_oneof_key_instance::hash(ref v)) = self.key_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Key_oneof_key_instance::uref(ref v)) = self.key_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::account(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::hash(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_instance = ::std::option::Option::Some(Key_oneof_key_instance::uref(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.key_instance {
            match v {
                &Key_oneof_key_instance::account(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Key_oneof_key_instance::hash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Key_oneof_key_instance::uref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.key_instance {
            match v {
                &Key_oneof_key_instance::account(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Key_oneof_key_instance::hash(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Key_oneof_key_instance::uref(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyAccount>(
                    "account",
                    Key::has_account,
                    Key::get_account,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyHash>(
                    "hash",
                    Key::has_hash,
                    Key::get_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyURef>(
                    "uref",
                    Key::has_uref,
                    Key::get_uref,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Key>(
                    "Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key {
        static mut instance: ::protobuf::lazy::Lazy<Key> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Key,
        };
        unsafe {
            instance.get(Key::new)
        }
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_hash();
        self.clear_uref();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyAccount {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyAccount {
    pub fn new() -> KeyAccount {
        ::std::default::Default::default()
    }

    // bytes account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    pub fn get_account(&self) -> &[u8] {
        &self.account
    }
}

impl ::protobuf::Message for KeyAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyAccount {
        KeyAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account",
                    |m: &KeyAccount| { &m.account },
                    |m: &mut KeyAccount| { &mut m.account },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyAccount>(
                    "KeyAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyAccount {
        static mut instance: ::protobuf::lazy::Lazy<KeyAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyAccount,
        };
        unsafe {
            instance.get(KeyAccount::new)
        }
    }
}

impl ::protobuf::Clear for KeyAccount {
    fn clear(&mut self) {
        self.clear_account();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyHash {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyHash {
    pub fn new() -> KeyHash {
        ::std::default::Default::default()
    }

    // bytes key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
}

impl ::protobuf::Message for KeyHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyHash {
        KeyHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &KeyHash| { &m.key },
                    |m: &mut KeyHash| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyHash>(
                    "KeyHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyHash {
        static mut instance: ::protobuf::lazy::Lazy<KeyHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyHash,
        };
        unsafe {
            instance.get(KeyHash::new)
        }
    }
}

impl ::protobuf::Clear for KeyHash {
    fn clear(&mut self) {
        self.clear_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyURef {
    // message fields
    pub uref: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyURef {
    pub fn new() -> KeyURef {
        ::std::default::Default::default()
    }

    // bytes uref = 1;

    pub fn clear_uref(&mut self) {
        self.uref.clear();
    }

    // Param is passed by value, moved
    pub fn set_uref(&mut self, v: ::std::vec::Vec<u8>) {
        self.uref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uref(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uref
    }

    // Take field
    pub fn take_uref(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uref, ::std::vec::Vec::new())
    }

    pub fn get_uref(&self) -> &[u8] {
        &self.uref
    }
}

impl ::protobuf::Message for KeyURef {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uref)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uref.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.uref);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.uref.is_empty() {
            os.write_bytes(1, &self.uref)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyURef {
        KeyURef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uref",
                    |m: &KeyURef| { &m.uref },
                    |m: &mut KeyURef| { &mut m.uref },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyURef>(
                    "KeyURef",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyURef {
        static mut instance: ::protobuf::lazy::Lazy<KeyURef> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyURef,
        };
        unsafe {
            instance.get(KeyURef::new)
        }
    }
}

impl ::protobuf::Clear for KeyURef {
    fn clear(&mut self) {
        self.clear_uref();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyURef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyURef {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntList {
    // message fields
    pub list: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl IntList {
    pub fn new() -> IntList {
        ::std::default::Default::default()
    }

    // repeated int32 list = 1;

    pub fn clear_list(&mut self) {
        self.list.clear();
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.list
    }

    // Take field
    pub fn take_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.list, ::std::vec::Vec::new())
    }

    pub fn get_list(&self) -> &[i32] {
        &self.list
    }
}

impl ::protobuf::Message for IntList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.list {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.list {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntList {
        IntList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "list",
                    |m: &IntList| { &m.list },
                    |m: &mut IntList| { &mut m.list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IntList>(
                    "IntList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntList {
        static mut instance: ::protobuf::lazy::Lazy<IntList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IntList,
        };
        unsafe {
            instance.get(IntList::new)
        }
    }
}

impl ::protobuf::Clear for IntList {
    fn clear(&mut self) {
        self.clear_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value {
    // message oneof groups
    pub value_instance: ::std::option::Option<Value_oneof_value_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Value_oneof_value_instance {
    integer(i32),
    byte_arr(::std::vec::Vec<u8>),
    int_list(IntList),
    string_val(::std::string::String),
    account(Account),
    contract(Contract),
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // int32 integer = 1;

    pub fn clear_integer(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_integer(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::integer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_integer(&mut self, v: i32) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::integer(v))
    }

    pub fn get_integer(&self) -> i32 {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::integer(v)) => v,
            _ => 0,
        }
    }

    // bytes byte_arr = 2;

    pub fn clear_byte_arr(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_byte_arr(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_byte_arr(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_byte_arr(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(_)) = self.value_instance {
        } else {
            self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(::std::vec::Vec::new()));
        }
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_byte_arr(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_byte_arr() {
            match self.value_instance.take() {
                ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_byte_arr(&self) -> &[u8] {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(ref v)) => v,
            _ => &[],
        }
    }

    // .io.casperlabs.ipc.IntList int_list = 3;

    pub fn clear_int_list(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_int_list(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::int_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_list(&mut self, v: IntList) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::int_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int_list(&mut self) -> &mut IntList {
        if let ::std::option::Option::Some(Value_oneof_value_instance::int_list(_)) = self.value_instance {
        } else {
            self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::int_list(IntList::new()));
        }
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::int_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int_list(&mut self) -> IntList {
        if self.has_int_list() {
            match self.value_instance.take() {
                ::std::option::Option::Some(Value_oneof_value_instance::int_list(v)) => v,
                _ => panic!(),
            }
        } else {
            IntList::new()
        }
    }

    pub fn get_int_list(&self) -> &IntList {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::int_list(ref v)) => v,
            _ => IntList::default_instance(),
        }
    }

    // string string_val = 4;

    pub fn clear_string_val(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_string_val(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::string_val(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_val(&mut self, v: ::std::string::String) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::string_val(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_val(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Value_oneof_value_instance::string_val(_)) = self.value_instance {
        } else {
            self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::string_val(::std::string::String::new()));
        }
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::string_val(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_val(&mut self) -> ::std::string::String {
        if self.has_string_val() {
            match self.value_instance.take() {
                ::std::option::Option::Some(Value_oneof_value_instance::string_val(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_string_val(&self) -> &str {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::string_val(ref v)) => v,
            _ => "",
        }
    }

    // .io.casperlabs.ipc.Account account = 5;

    pub fn clear_account(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::account(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: Account) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::account(v))
    }

    // Mutable pointer to the field.
    pub fn mut_account(&mut self) -> &mut Account {
        if let ::std::option::Option::Some(Value_oneof_value_instance::account(_)) = self.value_instance {
        } else {
            self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::account(Account::new()));
        }
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::account(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account(&mut self) -> Account {
        if self.has_account() {
            match self.value_instance.take() {
                ::std::option::Option::Some(Value_oneof_value_instance::account(v)) => v,
                _ => panic!(),
            }
        } else {
            Account::new()
        }
    }

    pub fn get_account(&self) -> &Account {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::account(ref v)) => v,
            _ => Account::default_instance(),
        }
    }

    // .io.casperlabs.ipc.Contract contract = 6;

    pub fn clear_contract(&mut self) {
        self.value_instance = ::std::option::Option::None;
    }

    pub fn has_contract(&self) -> bool {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::contract(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: Contract) {
        self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::contract(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contract(&mut self) -> &mut Contract {
        if let ::std::option::Option::Some(Value_oneof_value_instance::contract(_)) = self.value_instance {
        } else {
            self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::contract(Contract::new()));
        }
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::contract(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contract(&mut self) -> Contract {
        if self.has_contract() {
            match self.value_instance.take() {
                ::std::option::Option::Some(Value_oneof_value_instance::contract(v)) => v,
                _ => panic!(),
            }
        } else {
            Contract::new()
        }
    }

    pub fn get_contract(&self) -> &Contract {
        match self.value_instance {
            ::std::option::Option::Some(Value_oneof_value_instance::contract(ref v)) => v,
            _ => Contract::default_instance(),
        }
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        if let Some(Value_oneof_value_instance::int_list(ref v)) = self.value_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Value_oneof_value_instance::account(ref v)) = self.value_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Value_oneof_value_instance::contract(ref v)) = self.value_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::integer(is.read_int32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::byte_arr(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::int_list(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::string_val(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::account(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value_instance = ::std::option::Option::Some(Value_oneof_value_instance::contract(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value_instance {
            match v {
                &Value_oneof_value_instance::integer(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Value_oneof_value_instance::byte_arr(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &Value_oneof_value_instance::int_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Value_oneof_value_instance::string_val(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &Value_oneof_value_instance::account(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Value_oneof_value_instance::contract(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value_instance {
            match v {
                &Value_oneof_value_instance::integer(v) => {
                    os.write_int32(1, v)?;
                },
                &Value_oneof_value_instance::byte_arr(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &Value_oneof_value_instance::int_list(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Value_oneof_value_instance::string_val(ref v) => {
                    os.write_string(4, v)?;
                },
                &Value_oneof_value_instance::account(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Value_oneof_value_instance::contract(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "integer",
                    Value::has_integer,
                    Value::get_integer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "byte_arr",
                    Value::has_byte_arr,
                    Value::get_byte_arr,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IntList>(
                    "int_list",
                    Value::has_int_list,
                    Value::get_int_list,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "string_val",
                    Value::has_string_val,
                    Value::get_string_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Account>(
                    "account",
                    Value::has_account,
                    Value::get_account,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Contract>(
                    "contract",
                    Value::has_contract,
                    Value::get_contract,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(Value::new)
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.clear_integer();
        self.clear_byte_arr();
        self.clear_int_list();
        self.clear_string_val();
        self.clear_account();
        self.clear_contract();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Account {
    // message fields
    pub pub_key: ::std::vec::Vec<u8>,
    pub nonce: i64,
    pub known_urefs: ::protobuf::RepeatedField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    // bytes pub_key = 1;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pub_key, ::std::vec::Vec::new())
    }

    pub fn get_pub_key(&self) -> &[u8] {
        &self.pub_key
    }

    // int64 nonce = 2;

    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i64) {
        self.nonce = v;
    }

    pub fn get_nonce(&self) -> i64 {
        self.nonce
    }

    // repeated .io.casperlabs.ipc.Key known_urefs = 3;

    pub fn clear_known_urefs(&mut self) {
        self.known_urefs.clear();
    }

    // Param is passed by value, moved
    pub fn set_known_urefs(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.known_urefs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_known_urefs(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.known_urefs
    }

    // Take field
    pub fn take_known_urefs(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.known_urefs, ::protobuf::RepeatedField::new())
    }

    pub fn get_known_urefs(&self) -> &[Key] {
        &self.known_urefs
    }
}

impl ::protobuf::Message for Account {
    fn is_initialized(&self) -> bool {
        for v in &self.known_urefs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.known_urefs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.pub_key);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.known_urefs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_bytes(1, &self.pub_key)?;
        }
        if self.nonce != 0 {
            os.write_int64(2, self.nonce)?;
        }
        for v in &self.known_urefs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account {
        Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pub_key",
                    |m: &Account| { &m.pub_key },
                    |m: &mut Account| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nonce",
                    |m: &Account| { &m.nonce },
                    |m: &mut Account| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "known_urefs",
                    |m: &Account| { &m.known_urefs },
                    |m: &mut Account| { &mut m.known_urefs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Account>(
                    "Account",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Account {
        static mut instance: ::protobuf::lazy::Lazy<Account> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Account,
        };
        unsafe {
            instance.get(Account::new)
        }
    }
}

impl ::protobuf::Clear for Account {
    fn clear(&mut self) {
        self.clear_pub_key();
        self.clear_nonce();
        self.clear_known_urefs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Contract {
    // message fields
    pub body: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Contract {
    pub fn new() -> Contract {
        ::std::default::Default::default()
    }

    // bytes body = 1;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.body, ::std::vec::Vec::new())
    }

    pub fn get_body(&self) -> &[u8] {
        &self.body
    }
}

impl ::protobuf::Message for Contract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.body.is_empty() {
            os.write_bytes(1, &self.body)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Contract {
        Contract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "body",
                    |m: &Contract| { &m.body },
                    |m: &mut Contract| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Contract>(
                    "Contract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Contract {
        static mut instance: ::protobuf::lazy::Lazy<Contract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Contract,
        };
        unsafe {
            instance.get(Contract::new)
        }
    }
}

impl ::protobuf::Clear for Contract {
    fn clear(&mut self) {
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Contract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Contract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transform {
    // message oneof groups
    pub transform_instance: ::std::option::Option<Transform_oneof_transform_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Transform_oneof_transform_instance {
    identity(TransformIdentity),
    add(TransformAdd),
    write(TransformWrite),
}

impl Transform {
    pub fn new() -> Transform {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.TransformIdentity identity = 1;

    pub fn clear_identity(&mut self) {
        self.transform_instance = ::std::option::Option::None;
    }

    pub fn has_identity(&self) -> bool {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::identity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: TransformIdentity) {
        self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::identity(v))
    }

    // Mutable pointer to the field.
    pub fn mut_identity(&mut self) -> &mut TransformIdentity {
        if let ::std::option::Option::Some(Transform_oneof_transform_instance::identity(_)) = self.transform_instance {
        } else {
            self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::identity(TransformIdentity::new()));
        }
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::identity(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_identity(&mut self) -> TransformIdentity {
        if self.has_identity() {
            match self.transform_instance.take() {
                ::std::option::Option::Some(Transform_oneof_transform_instance::identity(v)) => v,
                _ => panic!(),
            }
        } else {
            TransformIdentity::new()
        }
    }

    pub fn get_identity(&self) -> &TransformIdentity {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::identity(ref v)) => v,
            _ => TransformIdentity::default_instance(),
        }
    }

    // .io.casperlabs.ipc.TransformAdd add = 2;

    pub fn clear_add(&mut self) {
        self.transform_instance = ::std::option::Option::None;
    }

    pub fn has_add(&self) -> bool {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::add(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: TransformAdd) {
        self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::add(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut TransformAdd {
        if let ::std::option::Option::Some(Transform_oneof_transform_instance::add(_)) = self.transform_instance {
        } else {
            self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::add(TransformAdd::new()));
        }
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::add(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add(&mut self) -> TransformAdd {
        if self.has_add() {
            match self.transform_instance.take() {
                ::std::option::Option::Some(Transform_oneof_transform_instance::add(v)) => v,
                _ => panic!(),
            }
        } else {
            TransformAdd::new()
        }
    }

    pub fn get_add(&self) -> &TransformAdd {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::add(ref v)) => v,
            _ => TransformAdd::default_instance(),
        }
    }

    // .io.casperlabs.ipc.TransformWrite write = 3;

    pub fn clear_write(&mut self) {
        self.transform_instance = ::std::option::Option::None;
    }

    pub fn has_write(&self) -> bool {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::write(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: TransformWrite) {
        self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::write(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write(&mut self) -> &mut TransformWrite {
        if let ::std::option::Option::Some(Transform_oneof_transform_instance::write(_)) = self.transform_instance {
        } else {
            self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::write(TransformWrite::new()));
        }
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::write(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write(&mut self) -> TransformWrite {
        if self.has_write() {
            match self.transform_instance.take() {
                ::std::option::Option::Some(Transform_oneof_transform_instance::write(v)) => v,
                _ => panic!(),
            }
        } else {
            TransformWrite::new()
        }
    }

    pub fn get_write(&self) -> &TransformWrite {
        match self.transform_instance {
            ::std::option::Option::Some(Transform_oneof_transform_instance::write(ref v)) => v,
            _ => TransformWrite::default_instance(),
        }
    }
}

impl ::protobuf::Message for Transform {
    fn is_initialized(&self) -> bool {
        if let Some(Transform_oneof_transform_instance::identity(ref v)) = self.transform_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transform_oneof_transform_instance::add(ref v)) = self.transform_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transform_oneof_transform_instance::write(ref v)) = self.transform_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::identity(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::add(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.transform_instance = ::std::option::Option::Some(Transform_oneof_transform_instance::write(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.transform_instance {
            match v {
                &Transform_oneof_transform_instance::identity(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transform_oneof_transform_instance::add(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transform_oneof_transform_instance::write(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.transform_instance {
            match v {
                &Transform_oneof_transform_instance::identity(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transform_oneof_transform_instance::add(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transform_oneof_transform_instance::write(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transform {
        Transform::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransformIdentity>(
                    "identity",
                    Transform::has_identity,
                    Transform::get_identity,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransformAdd>(
                    "add",
                    Transform::has_add,
                    Transform::get_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransformWrite>(
                    "write",
                    Transform::has_write,
                    Transform::get_write,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transform>(
                    "Transform",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transform {
        static mut instance: ::protobuf::lazy::Lazy<Transform> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transform,
        };
        unsafe {
            instance.get(Transform::new)
        }
    }
}

impl ::protobuf::Clear for Transform {
    fn clear(&mut self) {
        self.clear_identity();
        self.clear_add();
        self.clear_write();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transform {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransformIdentity {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransformIdentity {
    pub fn new() -> TransformIdentity {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransformIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransformIdentity {
        TransformIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TransformIdentity>(
                    "TransformIdentity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransformIdentity {
        static mut instance: ::protobuf::lazy::Lazy<TransformIdentity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransformIdentity,
        };
        unsafe {
            instance.get(TransformIdentity::new)
        }
    }
}

impl ::protobuf::Clear for TransformIdentity {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransformIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransformIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransformAdd {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransformAdd {
    pub fn new() -> TransformAdd {
        ::std::default::Default::default()
    }

    // int32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    pub fn get_value(&self) -> i32 {
        self.value
    }
}

impl ::protobuf::Message for TransformAdd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransformAdd {
        TransformAdd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &TransformAdd| { &m.value },
                    |m: &mut TransformAdd| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransformAdd>(
                    "TransformAdd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransformAdd {
        static mut instance: ::protobuf::lazy::Lazy<TransformAdd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransformAdd,
        };
        unsafe {
            instance.get(TransformAdd::new)
        }
    }
}

impl ::protobuf::Clear for TransformAdd {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransformAdd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransformAdd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransformWrite {
    // message fields
    pub value: ::protobuf::SingularPtrField<Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransformWrite {
    pub fn new() -> TransformWrite {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Value {
        self.value.take().unwrap_or_else(|| Value::new())
    }

    pub fn get_value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| Value::default_instance())
    }
}

impl ::protobuf::Message for TransformWrite {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransformWrite {
        TransformWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "value",
                    |m: &TransformWrite| { &m.value },
                    |m: &mut TransformWrite| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransformWrite>(
                    "TransformWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransformWrite {
        static mut instance: ::protobuf::lazy::Lazy<TransformWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransformWrite,
        };
        unsafe {
            instance.get(TransformWrite::new)
        }
    }
}

impl ::protobuf::Clear for TransformWrite {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransformWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransformWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpEntry {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    pub operation: ::protobuf::SingularPtrField<Op>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OpEntry {
    pub fn new() -> OpEntry {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.Key key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }

    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| Key::default_instance())
    }

    // .io.casperlabs.ipc.Op operation = 2;

    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: Op) {
        self.operation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut Op {
        if self.operation.is_none() {
            self.operation.set_default();
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> Op {
        self.operation.take().unwrap_or_else(|| Op::new())
    }

    pub fn get_operation(&self) -> &Op {
        self.operation.as_ref().unwrap_or_else(|| Op::default_instance())
    }
}

impl ::protobuf::Message for OpEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.operation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpEntry {
        OpEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "key",
                    |m: &OpEntry| { &m.key },
                    |m: &mut OpEntry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Op>>(
                    "operation",
                    |m: &OpEntry| { &m.operation },
                    |m: &mut OpEntry| { &mut m.operation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpEntry>(
                    "OpEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpEntry {
        static mut instance: ::protobuf::lazy::Lazy<OpEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpEntry,
        };
        unsafe {
            instance.get(OpEntry::new)
        }
    }
}

impl ::protobuf::Clear for OpEntry {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_operation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransformEntry {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    pub transform: ::protobuf::SingularPtrField<Transform>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransformEntry {
    pub fn new() -> TransformEntry {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.Key key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }

    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| Key::default_instance())
    }

    // .io.casperlabs.ipc.Transform transform = 2;

    pub fn clear_transform(&mut self) {
        self.transform.clear();
    }

    pub fn has_transform(&self) -> bool {
        self.transform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transform(&mut self, v: Transform) {
        self.transform = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transform(&mut self) -> &mut Transform {
        if self.transform.is_none() {
            self.transform.set_default();
        }
        self.transform.as_mut().unwrap()
    }

    // Take field
    pub fn take_transform(&mut self) -> Transform {
        self.transform.take().unwrap_or_else(|| Transform::new())
    }

    pub fn get_transform(&self) -> &Transform {
        self.transform.as_ref().unwrap_or_else(|| Transform::default_instance())
    }
}

impl ::protobuf::Message for TransformEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transform)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transform.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transform.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransformEntry {
        TransformEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "key",
                    |m: &TransformEntry| { &m.key },
                    |m: &mut TransformEntry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transform>>(
                    "transform",
                    |m: &TransformEntry| { &m.transform },
                    |m: &mut TransformEntry| { &mut m.transform },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransformEntry>(
                    "TransformEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransformEntry {
        static mut instance: ::protobuf::lazy::Lazy<TransformEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransformEntry,
        };
        unsafe {
            instance.get(TransformEntry::new)
        }
    }
}

impl ::protobuf::Clear for TransformEntry {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_transform();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransformEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransformEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionEffect {
    // message fields
    pub op_map: ::protobuf::RepeatedField<OpEntry>,
    pub transform_map: ::protobuf::RepeatedField<TransformEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ExecutionEffect {
    pub fn new() -> ExecutionEffect {
        ::std::default::Default::default()
    }

    // repeated .io.casperlabs.ipc.OpEntry op_map = 1;

    pub fn clear_op_map(&mut self) {
        self.op_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_map(&mut self, v: ::protobuf::RepeatedField<OpEntry>) {
        self.op_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_op_map(&mut self) -> &mut ::protobuf::RepeatedField<OpEntry> {
        &mut self.op_map
    }

    // Take field
    pub fn take_op_map(&mut self) -> ::protobuf::RepeatedField<OpEntry> {
        ::std::mem::replace(&mut self.op_map, ::protobuf::RepeatedField::new())
    }

    pub fn get_op_map(&self) -> &[OpEntry] {
        &self.op_map
    }

    // repeated .io.casperlabs.ipc.TransformEntry transform_map = 2;

    pub fn clear_transform_map(&mut self) {
        self.transform_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_transform_map(&mut self, v: ::protobuf::RepeatedField<TransformEntry>) {
        self.transform_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transform_map(&mut self) -> &mut ::protobuf::RepeatedField<TransformEntry> {
        &mut self.transform_map
    }

    // Take field
    pub fn take_transform_map(&mut self) -> ::protobuf::RepeatedField<TransformEntry> {
        ::std::mem::replace(&mut self.transform_map, ::protobuf::RepeatedField::new())
    }

    pub fn get_transform_map(&self) -> &[TransformEntry] {
        &self.transform_map
    }
}

impl ::protobuf::Message for ExecutionEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.op_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transform_map {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.op_map)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transform_map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.op_map {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.transform_map {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.op_map {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.transform_map {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionEffect {
        ExecutionEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpEntry>>(
                    "op_map",
                    |m: &ExecutionEffect| { &m.op_map },
                    |m: &mut ExecutionEffect| { &mut m.op_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransformEntry>>(
                    "transform_map",
                    |m: &ExecutionEffect| { &m.transform_map },
                    |m: &mut ExecutionEffect| { &mut m.transform_map },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutionEffect>(
                    "ExecutionEffect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecutionEffect {
        static mut instance: ::protobuf::lazy::Lazy<ExecutionEffect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutionEffect,
        };
        unsafe {
            instance.get(ExecutionEffect::new)
        }
    }
}

impl ::protobuf::Clear for ExecutionEffect {
    fn clear(&mut self) {
        self.clear_op_map();
        self.clear_transform_map();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeployError {
    // message oneof groups
    pub deploy_errors: ::std::option::Option<DeployError_oneof_deploy_errors>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum DeployError_oneof_deploy_errors {
    gasErr(OutOfGasError),
    wasmErr(WasmError),
}

impl DeployError {
    pub fn new() -> DeployError {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.OutOfGasError gasErr = 1;

    pub fn clear_gasErr(&mut self) {
        self.deploy_errors = ::std::option::Option::None;
    }

    pub fn has_gasErr(&self) -> bool {
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gasErr(&mut self, v: OutOfGasError) {
        self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gasErr(&mut self) -> &mut OutOfGasError {
        if let ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(_)) = self.deploy_errors {
        } else {
            self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(OutOfGasError::new()));
        }
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gasErr(&mut self) -> OutOfGasError {
        if self.has_gasErr() {
            match self.deploy_errors.take() {
                ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(v)) => v,
                _ => panic!(),
            }
        } else {
            OutOfGasError::new()
        }
    }

    pub fn get_gasErr(&self) -> &OutOfGasError {
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(ref v)) => v,
            _ => OutOfGasError::default_instance(),
        }
    }

    // .io.casperlabs.ipc.WasmError wasmErr = 2;

    pub fn clear_wasmErr(&mut self) {
        self.deploy_errors = ::std::option::Option::None;
    }

    pub fn has_wasmErr(&self) -> bool {
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wasmErr(&mut self, v: WasmError) {
        self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wasmErr(&mut self) -> &mut WasmError {
        if let ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(_)) = self.deploy_errors {
        } else {
            self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(WasmError::new()));
        }
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wasmErr(&mut self) -> WasmError {
        if self.has_wasmErr() {
            match self.deploy_errors.take() {
                ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(v)) => v,
                _ => panic!(),
            }
        } else {
            WasmError::new()
        }
    }

    pub fn get_wasmErr(&self) -> &WasmError {
        match self.deploy_errors {
            ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(ref v)) => v,
            _ => WasmError::default_instance(),
        }
    }
}

impl ::protobuf::Message for DeployError {
    fn is_initialized(&self) -> bool {
        if let Some(DeployError_oneof_deploy_errors::gasErr(ref v)) = self.deploy_errors {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DeployError_oneof_deploy_errors::wasmErr(ref v)) = self.deploy_errors {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::gasErr(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deploy_errors = ::std::option::Option::Some(DeployError_oneof_deploy_errors::wasmErr(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.deploy_errors {
            match v {
                &DeployError_oneof_deploy_errors::gasErr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DeployError_oneof_deploy_errors::wasmErr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.deploy_errors {
            match v {
                &DeployError_oneof_deploy_errors::gasErr(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DeployError_oneof_deploy_errors::wasmErr(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployError {
        DeployError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OutOfGasError>(
                    "gasErr",
                    DeployError::has_gasErr,
                    DeployError::get_gasErr,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WasmError>(
                    "wasmErr",
                    DeployError::has_wasmErr,
                    DeployError::get_wasmErr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeployError>(
                    "DeployError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeployError {
        static mut instance: ::protobuf::lazy::Lazy<DeployError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeployError,
        };
        unsafe {
            instance.get(DeployError::new)
        }
    }
}

impl ::protobuf::Clear for DeployError {
    fn clear(&mut self) {
        self.clear_gasErr();
        self.clear_wasmErr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutOfGasError {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OutOfGasError {
    pub fn new() -> OutOfGasError {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OutOfGasError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutOfGasError {
        OutOfGasError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<OutOfGasError>(
                    "OutOfGasError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OutOfGasError {
        static mut instance: ::protobuf::lazy::Lazy<OutOfGasError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OutOfGasError,
        };
        unsafe {
            instance.get(OutOfGasError::new)
        }
    }
}

impl ::protobuf::Clear for OutOfGasError {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutOfGasError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutOfGasError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WasmError {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WasmError {
    pub fn new() -> WasmError {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for WasmError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WasmError {
        WasmError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &WasmError| { &m.message },
                    |m: &mut WasmError| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WasmError>(
                    "WasmError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WasmError {
        static mut instance: ::protobuf::lazy::Lazy<WasmError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WasmError,
        };
        unsafe {
            instance.get(WasmError::new)
        }
    }
}

impl ::protobuf::Clear for WasmError {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WasmError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WasmError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeployResult {
    // message oneof groups
    pub result: ::std::option::Option<DeployResult_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum DeployResult_oneof_result {
    effects(ExecutionEffect),
    error(DeployError),
}

impl DeployResult {
    pub fn new() -> DeployResult {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.ExecutionEffect effects = 1;

    pub fn clear_effects(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_effects(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::effects(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ExecutionEffect) {
        self.result = ::std::option::Option::Some(DeployResult_oneof_result::effects(v))
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ExecutionEffect {
        if let ::std::option::Option::Some(DeployResult_oneof_result::effects(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DeployResult_oneof_result::effects(ExecutionEffect::new()));
        }
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::effects(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_effects(&mut self) -> ExecutionEffect {
        if self.has_effects() {
            match self.result.take() {
                ::std::option::Option::Some(DeployResult_oneof_result::effects(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecutionEffect::new()
        }
    }

    pub fn get_effects(&self) -> &ExecutionEffect {
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::effects(ref v)) => v,
            _ => ExecutionEffect::default_instance(),
        }
    }

    // .io.casperlabs.ipc.DeployError error = 2;

    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: DeployError) {
        self.result = ::std::option::Option::Some(DeployResult_oneof_result::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut DeployError {
        if let ::std::option::Option::Some(DeployResult_oneof_result::error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DeployResult_oneof_result::error(DeployError::new()));
        }
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> DeployError {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(DeployResult_oneof_result::error(v)) => v,
                _ => panic!(),
            }
        } else {
            DeployError::new()
        }
    }

    pub fn get_error(&self) -> &DeployError {
        match self.result {
            ::std::option::Option::Some(DeployResult_oneof_result::error(ref v)) => v,
            _ => DeployError::default_instance(),
        }
    }
}

impl ::protobuf::Message for DeployResult {
    fn is_initialized(&self) -> bool {
        if let Some(DeployResult_oneof_result::effects(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DeployResult_oneof_result::error(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DeployResult_oneof_result::effects(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DeployResult_oneof_result::error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DeployResult_oneof_result::effects(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DeployResult_oneof_result::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DeployResult_oneof_result::effects(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DeployResult_oneof_result::error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployResult {
        DeployResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecutionEffect>(
                    "effects",
                    DeployResult::has_effects,
                    DeployResult::get_effects,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DeployError>(
                    "error",
                    DeployResult::has_error,
                    DeployResult::get_error,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeployResult>(
                    "DeployResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeployResult {
        static mut instance: ::protobuf::lazy::Lazy<DeployResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeployResult,
        };
        unsafe {
            instance.get(DeployResult::new)
        }
    }
}

impl ::protobuf::Clear for DeployResult {
    fn clear(&mut self) {
        self.clear_effects();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommutativeEffects {
    // message fields
    pub effects: ::protobuf::RepeatedField<TransformEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommutativeEffects {
    pub fn new() -> CommutativeEffects {
        ::std::default::Default::default()
    }

    // repeated .io.casperlabs.ipc.TransformEntry effects = 1;

    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<TransformEntry>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<TransformEntry> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<TransformEntry> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }

    pub fn get_effects(&self) -> &[TransformEntry] {
        &self.effects
    }
}

impl ::protobuf::Message for CommutativeEffects {
    fn is_initialized(&self) -> bool {
        for v in &self.effects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.effects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.effects {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommutativeEffects {
        CommutativeEffects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransformEntry>>(
                    "effects",
                    |m: &CommutativeEffects| { &m.effects },
                    |m: &mut CommutativeEffects| { &mut m.effects },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommutativeEffects>(
                    "CommutativeEffects",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommutativeEffects {
        static mut instance: ::protobuf::lazy::Lazy<CommutativeEffects> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommutativeEffects,
        };
        unsafe {
            instance.get(CommutativeEffects::new)
        }
    }
}

impl ::protobuf::Clear for CommutativeEffects {
    fn clear(&mut self) {
        self.clear_effects();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommutativeEffects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommutativeEffects {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Done {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Done {
    pub fn new() -> Done {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Done {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Done {
        Done::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Done>(
                    "Done",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Done {
        static mut instance: ::protobuf::lazy::Lazy<Done> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Done,
        };
        unsafe {
            instance.get(Done::new)
        }
    }
}

impl ::protobuf::Clear for Done {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Done {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Done {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostEffectsError {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PostEffectsError {
    pub fn new() -> PostEffectsError {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PostEffectsError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostEffectsError {
        PostEffectsError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PostEffectsError>(
                    "PostEffectsError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PostEffectsError {
        static mut instance: ::protobuf::lazy::Lazy<PostEffectsError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PostEffectsError,
        };
        unsafe {
            instance.get(PostEffectsError::new)
        }
    }
}

impl ::protobuf::Clear for PostEffectsError {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostEffectsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostEffectsError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostEffectsResult {
    // message oneof groups
    pub result: ::std::option::Option<PostEffectsResult_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum PostEffectsResult_oneof_result {
    success(Done),
    error(PostEffectsError),
}

impl PostEffectsResult {
    pub fn new() -> PostEffectsResult {
        ::std::default::Default::default()
    }

    // .io.casperlabs.ipc.Done success = 1;

    pub fn clear_success(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::success(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: Done) {
        self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::success(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut Done {
        if let ::std::option::Option::Some(PostEffectsResult_oneof_result::success(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::success(Done::new()));
        }
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::success(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success(&mut self) -> Done {
        if self.has_success() {
            match self.result.take() {
                ::std::option::Option::Some(PostEffectsResult_oneof_result::success(v)) => v,
                _ => panic!(),
            }
        } else {
            Done::new()
        }
    }

    pub fn get_success(&self) -> &Done {
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::success(ref v)) => v,
            _ => Done::default_instance(),
        }
    }

    // .io.casperlabs.ipc.PostEffectsError error = 2;

    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: PostEffectsError) {
        self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut PostEffectsError {
        if let ::std::option::Option::Some(PostEffectsResult_oneof_result::error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::error(PostEffectsError::new()));
        }
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> PostEffectsError {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(PostEffectsResult_oneof_result::error(v)) => v,
                _ => panic!(),
            }
        } else {
            PostEffectsError::new()
        }
    }

    pub fn get_error(&self) -> &PostEffectsError {
        match self.result {
            ::std::option::Option::Some(PostEffectsResult_oneof_result::error(ref v)) => v,
            _ => PostEffectsError::default_instance(),
        }
    }
}

impl ::protobuf::Message for PostEffectsResult {
    fn is_initialized(&self) -> bool {
        if let Some(PostEffectsResult_oneof_result::success(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PostEffectsResult_oneof_result::error(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::success(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(PostEffectsResult_oneof_result::error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &PostEffectsResult_oneof_result::success(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PostEffectsResult_oneof_result::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &PostEffectsResult_oneof_result::success(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PostEffectsResult_oneof_result::error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostEffectsResult {
        PostEffectsResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Done>(
                    "success",
                    PostEffectsResult::has_success,
                    PostEffectsResult::get_success,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PostEffectsError>(
                    "error",
                    PostEffectsResult::has_error,
                    PostEffectsResult::get_error,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PostEffectsResult>(
                    "PostEffectsResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PostEffectsResult {
        static mut instance: ::protobuf::lazy::Lazy<PostEffectsResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PostEffectsResult,
        };
        unsafe {
            instance.get(PostEffectsResult::new)
        }
    }
}

impl ::protobuf::Clear for PostEffectsResult {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostEffectsResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostEffectsResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tipc.proto\x12\x11io.casperlabs.ipc\"\x8c\x02\n\x06Deploy\x12\x0e\n\
    \x02pk\x18\x01\x20\x01(\x0cR\x02pk\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\
    \x03R\ttimestamp\x12!\n\x0csession_code\x18\x03\x20\x01(\x0cR\x0bsession\
    Code\x12!\n\x0cpayment_code\x18\x04\x20\x01(\x0cR\x0bpaymentCode\x12\x1b\
    \n\tgas_limit\x18\x05\x20\x01(\x03R\x08gasLimit\x12\x1b\n\tgas_price\x18\
    \x06\x20\x01(\x03R\x08gasPrice\x12\x14\n\x05nonce\x18\x07\x20\x01(\x03R\
    \x05nonce\x12\x1d\n\ndeploy_sig\x18\x08\x20\x01(\x0cR\tdeploySig\x12\x1f\
    \n\x0bpayment_sig\x18\t\x20\x01(\x0cR\npaymentSig\"\xd5\x01\n\x02Op\x12/\
    \n\x04read\x18\x01\x20\x01(\x0b2\x19.io.casperlabs.ipc.ReadOpH\0R\x04rea\
    d\x122\n\x05write\x18\x02\x20\x01(\x0b2\x1a.io.casperlabs.ipc.WriteOpH\0\
    R\x05write\x12,\n\x03add\x18\x03\x20\x01(\x0b2\x18.io.casperlabs.ipc.Add\
    OpH\0R\x03add\x12-\n\x04noop\x18\x04\x20\x01(\x0b2\x17.io.casperlabs.ipc\
    .NoOpH\0R\x04noopB\r\n\x0bop_instance\"\x08\n\x06ReadOp\"\t\n\x07WriteOp\
    \"\x07\n\x05AddOp\"\x06\n\x04NoOp\"\xb4\x01\n\x03Key\x129\n\x07account\
    \x18\x01\x20\x01(\x0b2\x1d.io.casperlabs.ipc.KeyAccountH\0R\x07account\
    \x120\n\x04hash\x18\x02\x20\x01(\x0b2\x1a.io.casperlabs.ipc.KeyHashH\0R\
    \x04hash\x120\n\x04uref\x18\x03\x20\x01(\x0b2\x1a.io.casperlabs.ipc.KeyU\
    RefH\0R\x04urefB\x0e\n\x0ckey_instance\"&\n\nKeyAccount\x12\x18\n\x07acc\
    ount\x18\x01\x20\x01(\x0cR\x07account\"\x1b\n\x07KeyHash\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x0cR\x03key\"\x1d\n\x07KeyURef\x12\x12\n\x04uref\x18\
    \x01\x20\x01(\x0cR\x04uref\"\x1d\n\x07IntList\x12\x12\n\x04list\x18\x01\
    \x20\x03(\x05R\x04list\"\x9f\x02\n\x05Value\x12\x1a\n\x07integer\x18\x01\
    \x20\x01(\x05H\0R\x07integer\x12\x1b\n\x08byte_arr\x18\x02\x20\x01(\x0cH\
    \0R\x07byteArr\x127\n\x08int_list\x18\x03\x20\x01(\x0b2\x1a.io.casperlab\
    s.ipc.IntListH\0R\x07intList\x12\x1f\n\nstring_val\x18\x04\x20\x01(\tH\0\
    R\tstringVal\x126\n\x07account\x18\x05\x20\x01(\x0b2\x1a.io.casperlabs.i\
    pc.AccountH\0R\x07account\x129\n\x08contract\x18\x06\x20\x01(\x0b2\x1b.i\
    o.casperlabs.ipc.ContractH\0R\x08contractB\x10\n\x0evalue_instance\"q\n\
    \x07Account\x12\x17\n\x07pub_key\x18\x01\x20\x01(\x0cR\x06pubKey\x12\x14\
    \n\x05nonce\x18\x02\x20\x01(\x03R\x05nonce\x127\n\x0bknown_urefs\x18\x03\
    \x20\x03(\x0b2\x16.io.casperlabs.ipc.KeyR\nknownUrefs\"\x1e\n\x08Contrac\
    t\x12\x12\n\x04body\x18\x01\x20\x01(\x0cR\x04body\"\xd5\x01\n\tTransform\
    \x12B\n\x08identity\x18\x01\x20\x01(\x0b2$.io.casperlabs.ipc.TransformId\
    entityH\0R\x08identity\x123\n\x03add\x18\x02\x20\x01(\x0b2\x1f.io.casper\
    labs.ipc.TransformAddH\0R\x03add\x129\n\x05write\x18\x03\x20\x01(\x0b2!.\
    io.casperlabs.ipc.TransformWriteH\0R\x05writeB\x14\n\x12transform_instan\
    ce\"\x13\n\x11TransformIdentity\"$\n\x0cTransformAdd\x12\x14\n\x05value\
    \x18\x01\x20\x01(\x05R\x05value\"@\n\x0eTransformWrite\x12.\n\x05value\
    \x18\x01\x20\x01(\x0b2\x18.io.casperlabs.ipc.ValueR\x05value\"h\n\x07OpE\
    ntry\x12(\n\x03key\x18\x01\x20\x01(\x0b2\x16.io.casperlabs.ipc.KeyR\x03k\
    ey\x123\n\toperation\x18\x02\x20\x01(\x0b2\x15.io.casperlabs.ipc.OpR\top\
    eration\"v\n\x0eTransformEntry\x12(\n\x03key\x18\x01\x20\x01(\x0b2\x16.i\
    o.casperlabs.ipc.KeyR\x03key\x12:\n\ttransform\x18\x02\x20\x01(\x0b2\x1c\
    .io.casperlabs.ipc.TransformR\ttransform\"\x8c\x01\n\x0fExecutionEffect\
    \x121\n\x06op_map\x18\x01\x20\x03(\x0b2\x1a.io.casperlabs.ipc.OpEntryR\
    \x05opMap\x12F\n\rtransform_map\x18\x02\x20\x03(\x0b2!.io.casperlabs.ipc\
    .TransformEntryR\x0ctransformMap\"\x94\x01\n\x0bDeployError\x12:\n\x06ga\
    sErr\x18\x01\x20\x01(\x0b2\x20.io.casperlabs.ipc.OutOfGasErrorH\0R\x06ga\
    sErr\x128\n\x07wasmErr\x18\x02\x20\x01(\x0b2\x1c.io.casperlabs.ipc.WasmE\
    rrorH\0R\x07wasmErrB\x0f\n\rdeploy_errors\"\x0f\n\rOutOfGasError\"%\n\tW\
    asmError\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\x90\x01\n\
    \x0cDeployResult\x12>\n\x07effects\x18\x01\x20\x01(\x0b2\".io.casperlabs\
    .ipc.ExecutionEffectH\0R\x07effects\x126\n\x05error\x18\x02\x20\x01(\x0b\
    2\x1e.io.casperlabs.ipc.DeployErrorH\0R\x05errorB\x08\n\x06result\"Q\n\
    \x12CommutativeEffects\x12;\n\x07effects\x18\x01\x20\x03(\x0b2!.io.caspe\
    rlabs.ipc.TransformEntryR\x07effects\"\x06\n\x04Done\"\x12\n\x10PostEffe\
    ctsError\"\x8f\x01\n\x11PostEffectsResult\x123\n\x07success\x18\x01\x20\
    \x01(\x0b2\x17.io.casperlabs.ipc.DoneH\0R\x07success\x12;\n\x05error\x18\
    \x02\x20\x01(\x0b2#.io.casperlabs.ipc.PostEffectsErrorH\0R\x05errorB\x08\
    \n\x06result2\xc5\x01\n\x16ExecutionEngineService\x12J\n\nSendDeploy\x12\
    \x19.io.casperlabs.ipc.Deploy\x1a\x1f.io.casperlabs.ipc.DeployResult\"\0\
    \x12_\n\x0eExecuteEffects\x12%.io.casperlabs.ipc.CommutativeEffects\x1a$\
    .io.casperlabs.ipc.PostEffectsResult\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
